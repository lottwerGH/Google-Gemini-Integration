const SECRET_KEY = "Gemini Api Key"

/**
 * Sends a prompt to Gemini and returns the text response
 * @param {string} prompt - The input for Gemini
 * @return {string|Object} - The text response or error object
 */
function askGemini(prompt) {
  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${SECRET_KEY}`;
  const payload = {
    contents: [{ parts: [{ text: prompt }] }]
  };

  try {
    const response = UrlFetchApp.fetch(url, {
      contentType: "application/json",
      payload: JSON.stringify(payload)
    });
    const result = JSON.parse(response.getContentText());
    const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

    return text || "No text response found in Gemini output";
  } catch (e) {
    return {
      success: false,
      error: e.message,
      fullError: e
    };
  }
}

/**
 * Prompt template for Gemini to generate executable code.
 * @param {string} prompt - The user prompt
 * @return {string} - Full instruction string
 */
function buildInstruction(prompt) {
  return `
Generate Google Apps Script code for this prompt: ${prompt}:

1. Use ONLY GmailApp methods
2. Return the result of the code as result
3. No function wrappers - just executable code
4. Avoid chaining calls (e.g. thread.getMessages().filter())
5. Use var instead of let
6. Use string concatenation (+), not template literals
7. Call askGemini() for any actions requiring analysis, or if there is no code to generate based on the prompt
8. If today's date is needed, calculate it as the current date at midnight

Example valid responses:
\`\`\`javascript
var today = new Date();
today.setHours(0,0,0,0);
var threads = GmailApp.search('in:spam after:' + today.toISOString().split('T')[0]);
result = threads.reduce(function(count, thread) {
  return count + thread.getMessageCount();
}, 0);
\`\`\`

\`\`\`javascript
var threads = GmailApp.search('label:inbox is:unread');
if (threads.length > 0) {
  var message = threads[0].getMessages()[0];
  var plainBody = message.getPlainBody();
  var summary = askGemini('Summarize this email in 3 bullet points: ' + plainBody.substring(0, 10000));
  result = {
    subject: message.getSubject(),
    summary: summary
  };
}
\`\`\`
`;
}

/**
 * Asks Gemini for executable code and optionally validates the generated code before execution.
 * @param {string} prompt - The prompt that Gemini will try to solve.
 * @param {boolean} codeValidation - Whether to check generated code !important!
 * @return {string} - The result or error message.
 */
function runGeminiCode(prompt, codeValidation = true) {
  if (!prompt) {
    return "Error: No prompt provided";
  }

  const instruction = buildInstruction(prompt);
  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${SECRET_KEY}`;

  try {
    const response = UrlFetchApp.fetch(url, {
      method: "POST",
      contentType: "application/json",
      payload: JSON.stringify({ contents: [{ parts: [{ text: instruction }] }] })
    });

    const result = JSON.parse(response.getContentText());
    const generatedCode = result.candidates?.[0]?.content?.parts?.[0]?.text || "No code generated by Gemini";

    const execution = codeValidation ? safeExecute(generatedCode) : executeWithoutValidation(generatedCode);

    if (execution.success) {
      const parsedResult = JSON.stringify(execution.result, null, 3);
      print(parsedResult, "runGeminiCode");
      return parsedResult;
    } else {
      return `Error executing code:\n${execution.error}\n\nGenerated code:\n${generatedCode}`;
    }
  } catch (e) {
    return `Error in runGeminiCode: ${e.message}`;
  }
}
